

# 用 800 字以内的语言了解 Go 指针

这篇文章适用于那些不熟悉 Go 中指针或指针类型概念的程序员。

## 什么是指针？

简单地说，指针是一个指向另一个地址的值。这是教科书上的解释，但如果您来自一种不允许谈论变量地址的语言，那么它很可能用楔形文字编写。

让我们来分解一下。

## 什么是内存？

计算机内存（RAM）可以被认为是一系列盒子，一个接一个地排成一行。每个盒子或单元格都标有唯一的数字，该数字按顺序递增；这是单元的地址，它的存储位置。

![img](https://dave.cheney.net/wp-content/uploads/2017/04/memory.png)

每个单元格保存一个值。如果您知道某个单元格的内存地址，则可以转到该单元格并读取其内容。您可以在该单元格中放置一个值；替换以前存在的任何东西。

这就是关于记忆的全部知识。CPU 所做的一切都表现为获取值并将其存入内存单元。

# 什么是变量？

要编写一个程序来检索存储在内存位置 200 中的值，将其乘以 3 并将结果存入内存位置 201，我们可以用伪代码编写如下内容：

- 检索存储在地址 200 中的值并将其放入 CPU 中。
- 将CPU中存储的值乘以3。
- 将CPU中存储的值存入内存位置201。

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Untitled.png)


这正是早期程序的编写方式；程序员会保留一个内存位置列表，其中包含谁使用它、何时使用以及存储在那里的值代表什么。

显然，这是乏味且容易出错的，并且意味着在程序构建期间必须为内存中存储的每个可能的值分配一个地址。更糟糕的是，这种安排使得在程序运行时动态地为变量分配存储变得困难——想象一下，如果您必须仅使用全局变量来编写大型程序。

为了解决这个问题，创建了*变量*的概念。变量只是内存位置的一个方便的字母数字假名；标签或昵称。

现在，我们不讨论内存位置，而是讨论变量，它们是我们为内存位置提供的方便名称。之前的程序现在可以表示为：

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Untitled-1-300x203.png)

- 检索存储在变量中的值`a`并将其放入 CPU 中。
- 乘以 3
- 将值存入变量`b`。

这是同一个程序，有一个关键的改进——因为我们不再需要直接讨论内存位置，我们不再需要跟踪它们——这项苦差事就留给了编译器。

现在我们可以编写一个像这样的程序

```
变量 a = 6
变量 b = a * 3
```

编译器将确保为变量`a`和`b`分配唯一的内存位置，以便根据需要长时间保存其值。

# 什么是指针？

现在我们知道内存只是一系列编号的单元，变量只是编译器分配的内存位置的昵称，那么什么是指针？

*指针是指向另一个变量的内存地址的值。*

指针 *指向*变量的内存地址，就像变量 *代表*值的内存地址一样。

我们看一下这个程序片段

```
函数主() {
        := 200
        b := &a
        *b++
        fmt.Println(a)
}
```

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Screen-Shot-2017-04-26-at-19.30.35-300x126.png)

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Untitled-2-300x139.png)

在第一行`main` 我们声明一个新变量`a` 并为其赋值`200`。

接下来我们声明一个变量`b` 并为其分配 *地址*。请记住，我们不知道 存储的确切内存位置，但我们仍然可以将的地址存储在 中。 `a``a``a``b`

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Screen-Shot-2017-04-26-at-19.44.10-300x235.png)

由于 Go 的强类型本质，第三行可能是最令人困惑的。`b` 包含 变量的 *地址*`a`，但我们想要增加 存储在 中的*值*`a`。为此，我们必须 *取消引用* `b`，跟随指针 from`b`到`a`。

![img](https://dave.cheney.net/wp-content/uploads/2017/04/Screen-Shot-2017-04-26-at-19.35.07-300x232.png)

然后我们将值加一，并将其存储回存储在的内存位置中`b.`

最后一行打印 的值`a`，表明它已增加到 201。

# 结论

如果您来自一种没有指针概念的语言，或者每个变量都隐式地是一个指针，请不要惊慌，形成变量和指针如何关联的心理模型需要时间和练习。只要记住这条规则：

*指针是指向另一个变量的内存地址的值。*

下一篇：  [Go 中没有引用传递](https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go)

### 相关文章：

1. [Go 中的指针](https://dave.cheney.net/2014/03/17/pointers-in-go)
2. [Go 中没有引用传递](https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go)
3. [如果映射不是引用变量，那它是什么？](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it)
4. [法提赫的问题](https://dave.cheney.net/2020/05/16/fatihs-question)